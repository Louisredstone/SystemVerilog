本实验在DE1-SoC (revG)上完成。

本文档为傻瓜教程，意在完整地记录实现流程。

主要设计代码为led_flow.sv
管脚约束信息如下：

------

具体流程

1，创建项目（Quartus的基本使用）

1.1打开Quartus。<br>
![](2020-10-14-16-33-14.png)

1.2打开New Project Wizard。<br>
![](2020-10-14-16-34-27.png)

1.3Next，并设置路径、项目名称。<br>
![](2020-10-14-16-35-54.png)

1.4Next，显示文件夹不存在是否创建。<br>
![](2020-10-14-16-37-13.png)

1.5选择是。<br>
![](2020-10-14-16-37-42.png)

1.6默认使用Empty Project，Next。<br>
![](2020-10-14-16-39-05.png)

1.7按"..."选择设计文件。<br>
![](2020-10-14-16-40-09.png)

1.8点击“打开”以添加。<br>
![](2020-10-14-16-40-53.png)

1.9Next，选中相应的芯片型号。<br>DE1-SoC使用的是5CSEMA5F31C6N，除去最后一个字符N（我也不知道为什么要除去），即5CSEMA5F31C6。如需要在其它板卡上运行请自行寻找芯片型号。<br>
![](2020-10-14-16-43-40.png)

1.10Next。<br>
![](2020-10-14-16-44-04.png)

1.11Next。<br>这是最终结果，检查是否正确。如果不正确，则回退到前面的步骤进行修改。<br>
![](2020-10-14-16-44-16.png)

1.12Finish。<br>至此，项目创建完成。

2，让Quartus分析代码。

双击左侧Tasks格中Compile Design下的Analysis&Synthesis。分析开始。使用Ctrl+L或者点击![](2020-10-14-16-48-31.png)图标则是"Start Compilation"，会执行Compile Design下的所有步骤。目前这一步没有必要。这一步的目的是让Quartus知道顶层代码中有哪些端口。<br>
![](2020-10-14-16-47-41.png)

3，规定引脚信息。

3.1打开Assignment（工具栏）<br>
![](2020-10-14-16-50-31.png)

3.2<br>打开Assignment-Pin Planner，看到顶层设计（本工程中是led_flow）中的所有管脚。如果事先没有上一步的Analysis&Synthesis，那么这里将会是空的，看不到clk、led_o[9]等输入输出端口。<br>
![](2020-10-14-16-51-14.png)

3.3查阅官方文档，找到"DE1-SoC_v.5.1.3_HWrevF.revG_SystemCD\Schematic\DE1-SoC.pdf"，打开之。<br>
![](2020-10-14-16-56-21.png)

3.4Ctrl+F寻找内容"clock"（其他情况也可尝试"clk"等）（如果没有文字版schematic就只能肉眼寻找了），找到26项，其中最感兴趣的是第六页的内容。此处有四个clock，都含有"_50"后缀，意味着它们的频率都是50MHz。任选一个（例如AF14）。<br>
![](2020-10-14-16-58-21.png)

3.5切换到Pin Planner界面，双击clk的Location格，<br>
![](2020-10-14-18-23-02.png)

3.6键入"af14"（会自动补全为PIN_af14）<br>
![](2020-10-14-18-24-11.png)

3.7回车，发现Location中的值变成了大写，并且I/O Bank和VREF Group已自动补全。<br>
![](2020-10-14-18-24-46.png)

3.8按照3.4~3.7的步骤寻找“LED”，得到感兴趣的内容：<br>
![](2020-10-14-18-29-09.png)
去往19页，